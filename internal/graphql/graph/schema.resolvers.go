package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"errors"
	"fmt"
	"strings"
	models "subscriptions/internal/domain"
	"subscriptions/internal/graphql/graph/model"
	"time"

	"golang.org/x/exp/slog"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, commentsAllowed bool) (*model.Post, error) {

	const op = "graph.schema.resolvers.CreatePost"

	createdAt := time.Now()
	p := &model.Post{Title: title, Content: content, CommentsAllowed: commentsAllowed, CreatedAt: createdAt}
	postId, err := r.Post_.SavePost(ctx, p)
	if err != nil {
		r.Logger.Error("Failed to save post", err, op)
		return nil, fmt.Errorf("%s: Failed to save post: %w", op, err)
	}
	p.ID = postId
	return p, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, text string) (*model.Comment, error) {
	const op = "graph.schema.resolvers.CreateComment"
	if len(text) > 2000 {
		r.Logger.Error("Comment length must be <= 2000 letters", op)
		return nil, fmt.Errorf("%s: Comment length must be <= 2000 letters", op)
	}

	var err error
	post, err := r.Post_.GetPost(ctx, postID)

	if err != nil {
		if strings.Contains(err.Error(), "post not found") {
			r.Logger.Error("You try to leave comment on non existing post", op)
			return nil, fmt.Errorf("%s: You try to leave comment on non existing post", op)
		}
		r.Logger.Error("Didnt manage to check post's existance: %w", op, err)
		return nil, fmt.Errorf("%s: Didnt manage to check post's existance: %w", op, err)
	}
	lock := r.Lock.GetLock(postID)
	lock.Lock()
	defer lock.Unlock()
	if !post.CommentsAllowed {
		r.Logger.Info("You try to leave comment on post that doesnt allow it", op)
		return nil, fmt.Errorf("%s: ou try to leave comment on post that doesnt allow it", op)
	}
	createdAt := time.Now()
	comment := model.Comment{PostID: postID, Text: text, CreatedAt: createdAt}
	if parentID != nil {
		err = r.Comment_.CheckCommentId(ctx, parentID, postID)
		if err != nil {
			if strings.Contains(err.Error(), "comment not found") {
				r.Logger.Error("You try to leave answer on non existing comment", op)
				return nil, fmt.Errorf("%s: You try to leave answer on non existingcomment", op)
			}
			r.Logger.Error("Didnt manage to check comment's existance: %w", op, err)
			return nil, fmt.Errorf("%s: Didnt manage to check comment's existance: %w", op, err)
		}
		comment.ParentID = parentID
	}
	CommentId, err := r.Comment_.SaveComment(ctx, &comment)
	comment.ID = CommentId
	if err != nil {
		r.Logger.Error("Failed to save comment", err, op)
		return nil, fmt.Errorf("%s: failed to create balance: %w", op, err)
	}
	go func() {
		r.CommentAddedNotification <- &comment
	}()
	return &comment, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	const op = "graph.schema.resolvers.Posts"
	if r.Storage == nil {
		r.Logger.Error("Storage is not initialized", op)
		return nil, errors.New("storage is not initialized")
	}
	if r.Post_ == nil {
		r.Logger.Error("Post_ is not initialized", op)
		return nil, errors.New("Post_ is not initialized")
	}
	var resultPosts []*model.Post
	var dbPosts *[]models.Post

	dbPosts, err := r.Post_.GetAll(ctx)
	if err != nil {
		r.Logger.Error("Failed to get posts", err, op)
		return nil, fmt.Errorf("%s: failed to get posts: %w", op, err)
	}
	for _, post := range *dbPosts {
		resultPosts = append(resultPosts, &model.Post{ID: post.ID, Title: post.Title, Content: post.Content, CommentsAllowed: post.CommentsAllowed, CreatedAt: post.CreatedAt})
	}
	return resultPosts, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string, first *int32, after *string) (*model.Post, error) {
	const op = "graph.schema.resolvers.Post"
	r.Logger.Info("Fetching post", slog.String("postID", id))
	var err error
	post, err := r.Post_.GetPost(ctx, id)

	if err != nil {
		r.Logger.Error("Failed to get post", slog.String("postID", id), err, op)
		return nil, fmt.Errorf("%s: failed to get posts: %w", op, err)
	}
	lock := r.Lock.GetLock(id)
	lock.Lock()
	defer lock.Unlock()
	err = r.Comment_.CheckCommentId(ctx, after, post.ID)
	if err != nil {
		if !strings.Contains(err.Error(), "comment not found") {
			r.Logger.Error("Didnt manage to check comment's existance: %w", op, err)
			return nil, fmt.Errorf("%s: Didnt manage to check comment's existance: %w", op, err)
		}
	}
	r.Logger.Info("CHECKED WELL")

	dbComms, endCursor, hasNextpage, err := r.Comment_.GetComments(ctx, id, first, after)
	if err != nil {
		r.Logger.Error("Failed to get comments", slog.String("postID", id), err, op)
		return nil, fmt.Errorf("%s: failed to get posts: %w", op, err)
	}
	var edges []*model.CommentEdge
	for _, comm := range *dbComms {
		edges = append(edges, &model.CommentEdge{
			Cursor: comm.ID,
			Node: &model.Comment{
				ID:        comm.ID,
				PostID:    comm.PostID,
				Text:      comm.Text,
				ParentID:  &comm.ParentID,
				CreatedAt: comm.CreatedAt,
			},
		})
	}
	comments := &model.CommentConnection{
		Edges:       edges,
		EndCursor:   &endCursor,
		HasNextPage: hasNextpage,
	}
	resultPost := &model.Post{ID: post.ID, Title: post.Title, Content: post.Content, CommentsAllowed: post.CommentsAllowed, Comments: comments, CreatedAt: post.CreatedAt}
	return resultPost, nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	r.Logger.Debug("Subscription started", slog.String("postID", postID))
	comments := make(chan *model.Comment, 1)

	go func() {
		defer func() {
			close(comments)
			r.Logger.Info("Subscription closed for postID: %s", postID)
		}()

		for {
			select {
			case <-ctx.Done():
				r.Logger.Debug("Subscription context done for postID: %s, reason: %v", postID, ctx.Err())
				return
			case comment := <-r.CommentAddedNotification:
				r.Logger.Info("Received comment with text: %s for postID: %s", comment.Text, comment.PostID)
				if comment.PostID == postID {
					select {
					case comments <- comment:
						r.Logger.Debug("Sent comment with ID: %s to subscriber for postID: %s", comment.ID, postID)
					case <-ctx.Done():
						r.Logger.Debug("Subscription context done while sending comment for postID: %s, reason: %v", postID, ctx.Err())
						return
					}
				} else {
					r.Logger.Debug("Comment postID %s does not match subscription postID %s, skipping", comment.PostID, postID)
				}
			}
		}
	}()

	return comments, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
