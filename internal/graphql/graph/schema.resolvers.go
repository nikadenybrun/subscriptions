package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"strings"
	"subscriptions/internal/graphql/graph/model"
	"subscriptions/internal/services/comments"
	"subscriptions/internal/services/posts"
	"subscriptions/internal/storage/postgres"
	"time"

	"golang.org/x/exp/slog"
)

//go:generate go run github.com/vektra/mockery/v2@v2.40.2 --name=Post
type Post interface {
	GetAll(ctx context.Context, s *postgres.Storage) ([]posts.Posts, error)
	GetPost(ctx context.Context, s *postgres.Storage, id string) (*posts.Posts, error)
	SavePost(ctx context.Context, s *postgres.Storage, p *model.Post) (string, error)
}

//go:generate go run github.com/vektra/mockery/v2@v2.40.2 --name=Comment
type Comment interface {
	SaveComment(ctx context.Context, s *postgres.Storage, c *model.Comment) (string, error)
	GetComments(ctx context.Context, s *postgres.Storage, postId string, first *int32, after *string) ([]comments.Comments, string, bool, error)
	CheckCommentId(ctx context.Context, s *postgres.Storage, comtId string) error
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, commentsAllowed bool) (*model.Post, error) {
	const op = "graph.schema.resolvers.CreatePost"
	// var ps posts.Posts
	// r.Post_.Title = title
	// r.Post_.Content = content
	// r.Post_.CommentsAllowed = commentsAllowed
	// r.Post_.ID = uuid.New().String()
	p := &model.Post{Title: title, Content: content, CommentsAllowed: commentsAllowed}
	postId, err := r.Post_.SavePost(ctx, r.Storage, p)
	if err != nil {
		r.Logger.Error("Failed to save post", err, op)
		return nil, fmt.Errorf("%s: Failed to save post: %w", op, err)
	}
	p.ID = postId
	return p, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, text string) (*model.Comment, error) {
	const op = "graph.schema.resolvers.CreateComment"
	if len(text) > 2000 {
		r.Logger.Error("Comment length must be <= 2000 letters", op)
		return nil, fmt.Errorf("%s: Comment length must be <= 2000 letters", op)
	}

	var err error
	post, err := r.Post_.GetPost(ctx, r.Storage, postID)
	if err != nil {
		if strings.Contains(err.Error(), "post not found") {
			r.Logger.Error("You try to leave comment on non existing post", op)
			return nil, fmt.Errorf("%s: You try to leave comment on non existing post", op)
		}
		r.Logger.Error("Didnt manage to check post's existance: %w", op, err)
		return nil, fmt.Errorf("%s: Didnt manage to check post's existance: %w", op, err)
	}
	if !post.CommentsAllowed {
		r.Logger.Info("You try to leave comment on post that doesnt allow it", op)
		return nil, fmt.Errorf("%s: ou try to leave comment on post that doesnt allow it", op)
	}
	createdAt := time.Now()
	comment := model.Comment{PostID: postID, Text: text, CreatedAt: createdAt}
	// com.PostID = postID
	if parentID != nil {
		err = r.Comment_.CheckCommentId(ctx, r.Storage, *parentID)
		if err != nil {
			if strings.Contains(err.Error(), "comment not found") {
				r.Logger.Error("You try to leave answer on non existing comment", op)
				return nil, fmt.Errorf("%s: You try to leave answer on non existingcomment", op)
			}
			r.Logger.Error("Didnt manage to check comment's existance: %w", op, err)
			return nil, fmt.Errorf("%s: Didnt manage to check comment's existance: %w", op, err)
		}
		comment.ParentID = parentID
	}
	CommentId, err := r.Comment_.SaveComment(ctx, r.Storage, &comment)
	comment.ID = CommentId
	if err != nil {
		r.Logger.Error("Failed to save comment", err, op)
		return nil, fmt.Errorf("%s: failed to create balance: %w", op, err)
	}
	go func() {
		r.CommentAddedNotification <- &comment
	}()
	return &comment, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	const op = "graph.schema.resolvers.Posts"
	var resultPosts []*model.Post
	var dbPosts []posts.Posts
	dbPosts, err := r.Post_.GetAll(ctx, r.Storage)
	if err != nil {
		r.Logger.Error("Failed to get posts", err, op)
		return nil, fmt.Errorf("%s: failed to get posts: %w", op, err)
	}
	for _, post := range dbPosts {
		resultPosts = append(resultPosts, &model.Post{ID: post.ID, Title: post.Title, Content: post.Content, CommentsAllowed: post.CommentsAllowed})
	}
	return resultPosts, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string, first *int32, after *string) (*model.Post, error) {
	const op = "graph.schema.resolvers.Posts"
	r.Logger.Info("Fetching post", slog.String("postID", id))
	// var resultPost *model.Post
	var err error
	post, err := r.Post_.GetPost(ctx, r.Storage, id)
	if err != nil {
		r.Logger.Error("Failed to get post", slog.String("postID", id), err, op)
		return nil, fmt.Errorf("%s: failed to get posts: %w", op, err)
	}
	dbComms, endCursor, hasNextpage, err := r.Comment_.GetComments(ctx, r.Storage, id, first, after)
	if err != nil {
		r.Logger.Error("Failed to get comments", slog.String("postID", id), err, op)
		return nil, fmt.Errorf("%s: failed to get posts: %w", op, err)
	}
	var edges []*model.CommentEdge
	for _, comm := range dbComms {
		edges = append(edges, &model.CommentEdge{
			Cursor: comm.ID,
			Node: &model.Comment{
				ID:        comm.ID,
				PostID:    comm.PostID,
				Text:      comm.Text,
				ParentID:  &comm.ParentID,
				CreatedAt: comm.CreatedAt,
			},
		})
	}
	comments := &model.CommentConnection{
		Edges:       edges,
		EndCursor:   &endCursor,
		HasNextPage: hasNextpage,
	}
	resultPost := &model.Post{ID: post.ID, Title: post.Title, Content: post.Content, CommentsAllowed: post.CommentsAllowed, Comments: comments}
	return resultPost, nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	r.Logger.Debug("Subscription started for postID: %s", postID)
	comments := make(chan *model.Comment, 1)

	go func() {
		defer func() {
			close(comments)
			r.Logger.Info("Subscription closed for postID: %s", postID)
		}()

		for {
			select {
			case <-ctx.Done():
				r.Logger.Debug("Subscription context done for postID: %s, reason: %v", postID, ctx.Err())
				return
			case comment := <-r.CommentAddedNotification:
				r.Logger.Info("Received comment with text: %s for postID: %s", comment.Text, comment.PostID)
				if comment.PostID == postID {
					select {
					case comments <- comment:
						r.Logger.Debug("Sent comment with ID: %s to subscriber for postID: %s", comment.ID, postID)
					case <-ctx.Done():
						r.Logger.Debug("Subscription context done while sending comment for postID: %s, reason: %v", postID, ctx.Err())
						return
					}
				} else {
					r.Logger.Debug("Comment postID %s does not match subscription postID %s, skipping", comment.PostID, postID)
				}
			}
		}
	}()

	return comments, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
